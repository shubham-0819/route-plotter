<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Enhanced SVG Connection Generator with Arrow Adjustment</title>
  <style>
    body { font-family: Arial, sans-serif; }
  </style>
</head>
<body>
  <script>
    // Sample input list of trips (each trip has a source and destination)
    const trips = [
      { source: "A", destination: "B" },
      { source: "B", destination: "C" },
      { source: "C", destination: "D" },
      { source: "C", destination: "D" },
      { source: "C", destination: "D" },
      { source: "F", destination: "G" }, // rule 3: identical trip, nodes drawn one level up
    ];

    // Global configuration values
    const defaultY = 200;
    const upY = defaultY - 80;
    const radius = 5;
    const gap = 10;              // Configurable gap between the circle and the connection line
    const nodeSpacing = 180;
    const startXBase = 100;
    const arrowMarkerWidth = 10; // New configuration: width of the arrow marker to subtract

    // Predefined colors for nodes; if more nodes exist, colors will cycle.
    const colors = ['#FF5733', '#33FF57'];

    // Function to compute connection types between adjacent trips
    function computeConnections(trips) {
      let connections = [];
      for (let i = 0; i < trips.length - 1; i++) {
        const current = trips[i];
        const next = trips[i + 1];
        let connectionType = "";
        
        // Rule 3: If both the source and destination match in adjacent nodes
        if (current.source === next.source && current.destination === next.destination) {
          connectionType = "simple line (100px up)";
        }
        // Rule 1: If it is a continued trip (destination of current equals source of next)
        else if (current.destination === next.source) {
          connectionType = "simple line";
        }
        // Rule 2: Otherwise, connect with a line ending with an arrow
        else {
          connectionType = "line with arrow";
        }
        connections.push({
          fromIndex: i,
          toIndex: i + 1,
          connectionType: connectionType
        });
      }
      return connections;
    }

    // Compute node vertical positions. By default, all nodes are at defaultY.
    // If a connection uses Rule 3, then mark both nodes as "up".
    function computeNodePositions(trips, connections) {
      let nodeY = Array(trips.length).fill(defaultY);
      connections.forEach(conn => {
        if (conn.connectionType.includes("100px up")) {
          nodeY[conn.fromIndex] = upY;
          nodeY[conn.toIndex] = upY;
        }
      });
      return nodeY;
    }

    // Function to generate the SVG drawing based on trips and their connection types
    function drawSVG(trips, connections, nodeY) {
      const svgNS = "http://www.w3.org/2000/svg";
      // Create an SVG element
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", 180*trips.length);
      svg.setAttribute("height", "400");
      svg.style.border = "1px solid #ccc";

      // Define an arrow marker for lines that require an arrow
      const defs = document.createElementNS(svgNS, "defs");
      const marker = document.createElementNS(svgNS, "marker");
      marker.setAttribute("id", "arrow");
      marker.setAttribute("markerWidth", arrowMarkerWidth);
      marker.setAttribute("markerHeight", "10");
      marker.setAttribute("refX", "0");
      marker.setAttribute("refY", "3");
      marker.setAttribute("orient", "auto");
      const markerPath = document.createElementNS(svgNS, "path");
      markerPath.setAttribute("d", "M0,0 L0,6 L9,3 z");
      markerPath.setAttribute("fill", "#000");
      marker.appendChild(markerPath);
      defs.appendChild(marker);
      svg.appendChild(defs);

      // Draw each trip as a circle with text. Calculate x positions based on index.
      trips.forEach((trip, index) => {
        const x = startXBase + index * nodeSpacing;
        const y = nodeY[index];

        // Draw circle with a unique color
        const circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", radius);
        circle.setAttribute("stroke", colors[index % colors.length]);
        circle.setAttribute("stroke-width", "3");
        circle.setAttribute("fill", "#fff");
        svg.appendChild(circle);

        // Add text inside the circle to display the trip info
        const text = document.createElementNS(svgNS, "text");
        text.setAttribute("x", x);
        text.setAttribute("y", y + 40); // adjust for vertical centering
        text.setAttribute("font-size", "12");
        text.setAttribute("text-anchor", "middle");
        text.textContent = `${trip.source} - ${trip.destination}`;
        svg.appendChild(text);
      });

      // Draw the connections between trips
      connections.forEach(conn => {
        const fromIndex = conn.fromIndex;
        const toIndex = conn.toIndex;

        // Determine node x positions
        const fromX = startXBase + fromIndex * nodeSpacing;
        const toX = startXBase + toIndex * nodeSpacing;
        // Get node y positions (which might have been adjusted due to rule 3)
        const fromY = nodeY[fromIndex];
        const toY = nodeY[toIndex];

        // Adjust start and end points so the line doesn't touch the circle.
        // For horizontal connections, adjust x based on radius and gap.
        const startX = fromX + radius + gap;
        // For lines with an arrow marker, subtract the arrow width from the end point.
        const rawEndX = toX - radius - gap;
        const endX = conn.connectionType === "line with arrow" ? rawEndX - arrowMarkerWidth : rawEndX;
        const startY = fromY;
        const endY = toY;

        // Check if we need a Bézier curve (i.e. when nodes are at different vertical levels)
        if (startY !== endY) {
          // Calculate control points for a cubic Bézier curve.
          const cp1X = startX + (endX - startX) / 3;
          const cp1Y = startY;
          const cp2X = startX + 2 * (endX - startX) / 3;
          const cp2Y = endY;
          const path = document.createElementNS(svgNS, "path");
          const d = `M ${startX} ${startY} C ${cp1X} ${cp1Y}, ${cp2X} ${cp2Y}, ${endX} ${endY}`;
          path.setAttribute("d", d);
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", "#153bd1");
          path.setAttribute("stroke-width", "2");

          // If the connection is of type "line with arrow", attach an arrow marker.
          if (conn.connectionType === "line with arrow") {
            path.setAttribute("marker-end", "url(#arrow)");
          }
          svg.appendChild(path);
        } else {
          // Draw a straight line if both nodes are on the same level.
          const line = document.createElementNS(svgNS, "line");
          line.setAttribute("x1", startX);
          line.setAttribute("y1", startY);
          line.setAttribute("x2", endX);
          line.setAttribute("y2", endY);
          line.setAttribute("stroke", "#153bd1");
          line.setAttribute("stroke-width", "2");
          if (conn.connectionType === "line with arrow") {
            line.setAttribute("marker-end", "url(#arrow)");
          }
          svg.appendChild(line);
        }
      });

      // Append the SVG to the document body
      document.body.appendChild(svg);
    }

    // Process the input: compute connections and determine node positions.
    const connections = computeConnections(trips);
    const nodeY = computeNodePositions(trips, connections);
    
    console.log("Computed Connections:", connections);
    console.log("Node Y Positions:", nodeY);
    drawSVG(trips, connections, nodeY);
  </script>
</body>
</html>
